\chapter{Исследовательская часть}

\section{Пример работы}

Демонстрация работы программы приведена на рисунке \ref{img:work}.

\boximg{160mm}{work}{Демонстрация работы программы}

\section{Технические характеристики}

Технические характеристики устройства, на котором выполнялось тестирование:

\begin{itemize}
	\item[--] операционная система: Ubuntu \cite{ubuntu} 22.04.3 LTS;
	\item[--] оперативная память: 15 GB;
	\item[--] процессор: 12 * AMD Ryzen 5 4600H with Radeon Graphics \cite{amd}.
\end{itemize}


\section{Время выполнения алгоритмов}

Во время замеров времени система не была нагружена дополнительными пользовательскими процессами.

Замеры проводились с помощью разработанной функции GetCPU, которая использует модуль syscall \cite{syscall}. syscall.Rusage является структурой в пакете syscall, предназначенной для хранения информации о ресурсах, используемых процессом или потоком. Эта структура содержит различные поля, такие как Utime (время использования ЦПУ в пользовательском режиме), Stime (время использования ЦПУ в режиме ядра) и так далее.

Для получения времени использования ЦПУ, извлекаем атрибуты структуры Utime и Stime.

Выражение usage.Utime.Nano() + usage.Stime.Nano() возвращает сумму времени использования ЦПУ в наносекундах для процесса или потока. Это значение может быть использовано для измерения общего времени использования ЦПУ в пределах процесса или потока.

Результаты замеров приведены в таблице \ref{tbl:time}.

Обозначим: 
\begin{itemize}
	\item[--] 1 - Матричный Левенштейн;
	\item[--] 2 - Матричный Дамерау-Левештейн;
	\item[--] 3 - Рекурсивный Дамерау-Левенштейн;
	\item[--] 4 - Рекурсивный Дамерау-Левенштейн с кешем.
\end{itemize}


\begin{table}[h]
	\begin{center}
		\caption{Замер времени для строк, размером от 5 до 300}
		\label{tbl:time}
		\begin{tabular}{|c|c|c|c|c|}
			\hline
			                      & \multicolumn{4}{c|}{\bfseries Время, с}                                    \\ \cline{2-5}
			\bfseries Длина строк & \bfseries 1 & \bfseries 2 & \bfseries 3 & \bfseries 4
			\csvreader{inc/csv/time.csv}{}
			{\\\hline \csvcoli&\csvcolii&\csvcoliii&\csvcoliv&\csvcolv}
			\\\hline
		\end{tabular}
	\end{center}
\end{table}

\img{100mm}{graph}{Зависимость времени работы алгоритма вычисления расстояния Левенштейна и Дамерау-Левенштейна от длины строк (до 15 символов)}

\img{100mm}{graph1}{Зависимость времени работы алгоритма вычисления расстояния Левенштейна и Дамерау-Левенштейна от длины строк (до 300 символов, без рекурсивной реализации алгоритма Дамерау-Левенштейна)}
\newpage

\section{Использование памяти}

Алгоритмы, использующие матрицы, не отличаются друг от друга по потреблению памяти, поэтому сравним только рекурсивную и матричную реализации.

Матричный алгоритм Дамерау-Левенштейна:
\begin{equation}
	11\cdot len\mathrm{(int)} + len\mathrm{(rune)} \cdot (len(S_1) + len(S_2)) +  len\mathrm{(Matrix)},
\end{equation} где
\begin{equation}
	len\mathrm{(Matrix)} = (len(S_1) + len(S_2) + 2) \cdot len\mathrm{(int)} + 2 \cdot len\mathrm{(int)} + len\mathrm{(bool)},		
\end{equation}
где $len$ — оператор вычисления размера, $S_1$, $S_2$ — строки, $\mathrm{int}$ — целочисленный тип, $\mathrm{rune}$ — строковый тип в GO, $\mathrm{Matrix}$ - пользовательский тип данных, представляющий матрицу, $\mathrm{bool}$ - логический тип данных.

Рекурсивный алгоритм Дамерау-Левенштейна:
Максимальная глубина стека вызовов при рекурсивной реализации равна сумме длин входящих строк, соответственно, максимальный расход памяти
\begin{equation}
(len(S_1) + len(S_2)) \cdot (2 \cdot len\mathrm{(rune)} + 15 \cdot len\mathrm{(int)}),
\label{for:99}
\end{equation}
где $len$ — оператор вычисления размера, $S_1$, $S_2$ — строки, $\mathrm{int}$ — целочисленный тип, $\mathrm{rune}$ — строковый тип в GO.

Выделение памяти при работе алгоритмов указано на рисунке \ref{img:memory}.

\boximg{60mm}{memory}{Замеры производительности алгоритмов, выполненные при помощи команды \code{go test -bench . -benchmem}}

\section*{Вывод}

Рекурсивный алгоритм Дамерау-Левенштейна имеет большую вычислительную сложность и работает медленнее итеративных реализаций. Время выполнения рекурсивного алгоритма увеличивается экспоненциально с ростом длины строк. Например, на словах длиной 10 символов, матричная реализация алгоритма Дамерау-Левенштейна работает в минимум 12000 раз быстрее, чем рекурсивная реализация.

Однако, рекурсивный Дамерау-Левенштейна имеет преимущество в использовании памяти. Итеративные алгоритмы требуют большего объема памяти, так как их потребление памяти растет как произведение длин строк. В то же время, рекурсивный алгоритм требует памяти пропорционально сумме длин строк.

Алгоритм Дамерау-Левенштейна по времени выполнения сопоставим с алгоритмом Левенштейна.

