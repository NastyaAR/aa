\chapter{Исследовательская часть}

\section{Технические характеристики}

Технические характеристики устройства, на котором выполнялось тестирование:

\begin{itemize}
	\item[---] операционная система: Ubuntu \cite{ubuntu} 22.04.3 LTS;
	\item[---] оперативная память: 15 ГБ;
	\item[---] процессор: 12 ядер, AMD Ryzen 5 4600ГЦ with Radeon Graphics \cite{amd}.
\end{itemize}


\section{Время выполнения алгоритмов}

Во время замеров времени система не была нагружена дополнительными пользовательскими процессами.

Замеры проводились с помощью разработанной функции GetCPU, которая использует модуль syscall \cite{syscall}. syscall.Rusage является структурой в пакете syscall, предназначенной для хранения информации о ресурсах, используемых процессом или потоком. Эта структура содержит различные поля, такие как Utime (время использования ЦПУ в пользовательском режиме), Stime (время использования ЦПУ в режиме ядра) и так далее.

Для получения времени использования ЦПУ, извлекаем атрибуты структуры Utime и Stime.

Выражение usage.Utime.Nano() + usage.Stime.Nano() возвращает сумму времени использования ЦПУ в наносекундах для процесса или потока. Это значение может быть использовано для измерения общего времени использования ЦПУ в пределах процесса или потока.

Результаты замеров приведены в таблице \ref{tbl:time}.

Обозначим: 
\begin{itemize}
	\item[---] 1 --- матричный алгоритм вычисления расстояния Левенштейна между строками;
	\item[---] 2 --- матричный алгоритм вычисления расстояния между строками Дамерау-Левештейна;
	\item[---] 3 --- рекурсивный алгоритм вычисления расстояния между строками Дамерау-Левенштейна;
	\item[---] 4 --- рекурсивный алгоритм с кешем вычисления расстояния Дамерау-Левенштейна.
\end{itemize}


\begin{table}[h]
	\begin{center}
		\caption{Замер времени для строк, размером от 5 до 300}
		\label{tbl:time}
		\begin{tabular}{|c|c|c|c|c|}
			\hline
			                      & \multicolumn{4}{c|}{\bfseries Время, нс}                                    \\ \cline{2-5}
			\bfseries Длина строк & \bfseries 1 & \bfseries 2 & \bfseries 3 & \bfseries 4
			\csvreader{inc/csv/time.csv}{}
			{\\\hline \csvcoli&\csvcolii&\csvcoliii&\csvcoliv&\csvcolv}
			\\\hline
		\end{tabular}
	\end{center}
\end{table}

На следующем графике представлена зависимость времени работы алгоритма вычисления расстояния Левенштейна и Дамерау-Левенштейна от длины строк (до 15 символов).

\img{90mm}{graph}{Время работы алгоритмов вычисления расстояния между строками}

\pagebreak

На следующем графике представлена зависимость времени работы алгоритма вычисления расстояния Левенштейна и Дамерау-Левенштейна от длины строк (до 300 символов, без рекурсивной реализации алгоритма Дамерау-Левенштейна).

\img{90mm}{graph1}{Время работы алгоритмов вычисления расстояния между строками}

\newpage

\section{Использование памяти}

Алгоритмы, использующие матрицы, не отличаются друг от друга по потреблению памяти, поэтому ниже приведено сравнение только рекурсивной и матричной реализации.

Матричный алгоритм Дамерау-Левенштейна:
\begin{equation}
	11\cdot len\mathrm{(int)} + len\mathrm{(rune)} \cdot (len\mathrm{(S_1)} + len\mathrm{(S_2)}) +  len\mathrm{(Matrix)},
\end{equation} где
\begin{equation}
	len\mathrm{(Matrix)} = (len\mathrm{(S_1)} + len\mathrm{(S_2)} + 2) \cdot len\mathrm{(int)} + 2 \cdot len\mathrm{(int)} + len\mathrm{(bool)},		
\end{equation}
где $len$ --- оператор вычисления размера, $\mathrm{S_1}$, $\mathrm{S_2}$ --- строки, $\mathrm{int}$ --- целочисленный тип, $\mathrm{rune}$ --- строковый тип в Go, $\mathrm{Matrix}$ --- пользовательский тип данных, представляющий матрицу, $\mathrm{bool}$ --- логический тип данных.

Рекурсивный алгоритм Дамерау-Левенштейна:
Максимальная глубина стека вызовов при рекурсивной реализации равна сумме длин входящих строк, соответственно, максимальный расход памяти
\begin{equation}
(len\mathrm{(S_1)} + len\mathrm{(S_2)}) \cdot (2 \cdot len\mathrm{(rune)} + 15 \cdot len\mathrm{(int)}),
\label{for:99}
\end{equation}
где $len$ --- оператор вычисления размера, $\mathrm{S_1}$, $\mathrm{S_2}$ --- строки, $\mathrm{int}$ --- целочисленный тип, $\mathrm{rune}$ --- строковый тип в Go.

Выделение памяти при работе алгоритмов указано на рисунке 4.1. Получено при помощи команды: \code{go test -bench . -benchmem}

\pagebreak

\begin{lstinputlisting}[
	caption={Матричный (Левенштейн)},
	label={lst:memory},
	style={sh},
	]{../report/inc/lst/lst2.txt}
\end{lstinputlisting}

\pagebreak

\section*{Вывод}

Рекурсивный алгоритм Дамерау-Левенштейна имеет большую вычислительную сложность и работает медленнее итеративных реализаций. Время выполнения рекурсивного алгоритма увеличивается экспоненциально с ростом длины строк. Например, на словах длиной 10 символов, матричная реализация алгоритма Дамерау-Левенштейна работает минимум  в 12000 раз быстрее, чем рекурсивная реализация.

Однако, рекурсивный Дамерау-Левенштейна имеет преимущество в использовании памяти. Итеративные алгоритмы требуют большего объема памяти, так как их потребление памяти растет как произведение длин строк. В то же время, рекурсивный алгоритм требует памяти пропорционально сумме длин строк.

Алгоритм Дамерау-Левенштейна по времени выполнения сопоставим с алгоритмом Левенштейна.

