\chapter{Исследовательская часть}

\section{Технические характеристики}

Технические характеристики устройства, на котором выполнялось тестирование:

\begin{itemize}
	\item[---] операционная система: Ubuntu \cite{ubuntu} 22.04.3 LTS;
	\item[---] оперативная память: 15 ГБ;
	\item[---] процессор: 12 ядер, AMD Ryzen 5 4600ГЦ with Radeon Graphics \cite{amd}.
\end{itemize}


\section{Время выполнения алгоритмов}
Все замеры были проведены в одинаковых условиях.

Замеры проводились с помощью разработанной функции GetCPU, которая использует модуль syscall \cite{syscall}. syscall.Rusage является структурой в пакете syscall, предназначенной для хранения информации о ресурсах, используемых процессом или потоком. Эта структура содержит различные поля, такие как Utime (время использования ЦПУ в пользовательском режиме), Stime (время использования ЦПУ в режиме ядра) и так далее.

Для получения времени использования ЦПУ, извлекаем атрибуты структуры Utime и Stime.

Выражение usage.Utime.Nano() + usage.Stime.Nano() возвращает сумму времени использования ЦПУ в наносекундах для процесса или потока. Это значение может быть использовано для измерения общего времени использования ЦПУ в пределах процесса или потока.

Результаты замеров приведены в таблице \ref{tbl:time0}.

Обозначим: 
\begin{itemize}
	\item[---] 1 --- классический алгоритм умножения матриц без оптимизаций;
	\item[---] 2 --- оптимизированный классический алгоритм умножения матриц;
	\item[---] 3 --- алгоритм Винограда умножения матриц без оптимизаций;
	\item[---] 4 --- оптимизированный алгоритм Винограда умножения матриц;
	\item[---] 5 --- алгоритм Штрассена умножения матриц без оптимизаций;
	\item[---] 6 --- оптимизированный алгоритм Штрассена умножения матриц.
\end{itemize}


\begin{table}[h]
	\footnotesize
	\begin{center}
		\caption{Замер времени для матриц, размером от 10x10 до 460x460}
		\label{tbl:time0}
		\begin{tabular}{|c|c|c|c|c|c|c|}
			\hline
			                      & \multicolumn{6}{c|}{\bfseries Время, с}                                    \\ \cline{2-7}
			\bfseries Размер матриц & \bfseries 1 & \bfseries 2 & \bfseries 3 & \bfseries 4 & \bfseries 5 & \bfseries 6
			\csvreader{inc/csv/time0.csv}{}
			{\\\hline \csvcoli&\csvcolii&\csvcoliii&\csvcoliv&\csvcolv&\csvcolvi&\csvcolvii}
			\\\hline
		\end{tabular}
	\end{center}
\end{table}

На следующем графике представлена зависимость времени работы алгоритмов умножения матриц от размеров матриц.

\img{110mm}{graph}{Время работы алгоритмов умножения матриц}

\pagebreak

На следующем графике представлена зависимость времени работы алгоритмов умножения матриц: стандартного и алгоритма Винограда на чётных размерах матриц.

\img{110mm}{graph6}{Время работы алгоритмов умножения матриц при чётных размерах матриц}

На графике \ref{img:graph7} представлена зависимость времени работы алгоритмов умножения матриц: стандартного и алгоритма Винограда на нечётных размерах матриц.

\img{110mm}{graph7}{Время работы алгоритмов умножения матриц при нечётных размерах матриц}

\newpage

График \ref{img:graph8} представляет сравнение алгоритмов Винограда --- оптимизированного и неоптимизированного --- при чётных и нечётных размерах матриц.

\img{110mm}{graph8}{Время работы алгоритмов умножения матриц при нечётных размерах матриц}

\newpage

\section{Использование памяти}

Выделение памяти при работе алгоритмов указано в листинге \ref{lst:memory}. Получено при помощи команды: \code{go test -bench . -benchmem}.

\newpage

\begin{lstinputlisting}[
	caption={Использование памяти},
	label={lst:memory},
	style={sh},
	linerange{1-14},
	]{../report/inc/lst/lst2.txt}
\end{lstinputlisting}

\newpage

На рисунке \ref{img:graph9} представлено сравнение потребления памяти алгоритмами умножения матриц

\img{110mm}{graph9}{Память, потребляемая алгоритмами умножения матриц}

Алгоритм Штрассена потребляет больше всего памяти, а стандартный алгоритм умножения матриц и алгоритм Винограда умножения матриц потребляют соизмеримое друг с другом количество памяти.

\pagebreak

\section*{Вывод}

Рекурсивный алгоритм Штрассена умножения матриц теоретически эффективнее, классического алгоритма умножения матриц и алгоритма Винограда умножения матриц, однако тестирование показало, что реализация этого алгоритма работает медленнее всех остальных реализаций других алгоритмов (в 100 раз медленнее). Время выполнения рекурсивного алгоритма Штрассена увеличивается с увеличением размерности матриц.

Алгоритм Винограда умножения матриц оказался самым эффективным из реализованных алгоритмов. Его преимущество начинает выделяться уже на матрицах размером 10 на 10 (в 4 раза быстрее, чем классический алгоритм умножения матриц.

Оптимизации каждой из реализаций алгоритмов показывают улучшение производительности всех рассматриваемых алгоримов.

Рекурсивный алгоритм Штрассена также потребляет самое большое количество памяти среди всех представленных алгоритмов (в примерно 500 раз больше памяти). Стандартный алгоритм умножения матриц и алгоритм Винограда потребляют примерно одинаковое количество памяти. Стоит отметить, что оптимизации оказывают положительное влияние на количество потребляемой памяти.


