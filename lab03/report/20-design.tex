\chapter{Конструкторская часть}

\section{Разработка алгоритма блочной сортировки}

На рисунках \ref{img:block1} --- \ref{img:block2} приведена схема алгоритма блочной сортировки.

\pdfimg{185mm}{block1}{Схема алгоритма блочной сортировки: начальная инициализация корзин и распределение чисел по корзинам}

\pagebreak

\pdfimg{235mm}{block2}{Схема алгоритма блочной сортировки: рекурсивная часть и создание результирующего массива}

\pagebreak

На рисунке \ref{img:ins} приведена схема алгоритма сортировки вставками, используемого в алгоритме блочной сортировки.

\pdfimg{225mm}{ins}{Схема алгоритма сортировки вставками}

\pagebreak

\section{Разработка алгоритма поразрядной сортировки}

На рисунках \ref{img:radix1} --- \ref{img:radix3} приведена схема алгоритма поразрядной сортировки.

\pdfimg{170mm}{radix1}{Схема алгоритма поразрядной сортировки: начальная инициализация массивов и получение максимального количества разрядов}

\pagebreak

\pdfimg{150mm}{radix2}{Схема алгоритма поразрядной сортировки: цикл по разрядам (распределение чисел по текущему разряду)}

\pagebreak

\pdfimg{200mm}{radix3}{Схема алгоритма поразрядной сортировки: цикл по разрядам (объединение отсортированных частей в результирующий массив)}

\pagebreak

На рисунке \ref{img:getmpl} приведена схема алгоритма получения максимального количества разрядов числа в массиве, используемого в алгоритме поразрядной сортировки.

\pdfimg{130mm}{getmpl}{Схема алгоритма получения максимального количества разрядов числа в массиве}

На рисунке \ref{img:getpl} приведена схема алгоритма подпрограммы получения количества разрядов числа, используемого в алгоритме получения максимального количества разрядов числа в массиве.

\pdfimg{170mm}{getpl}{Схема алгоритма получения количества разрядов числа}

\pagebreak

\section{Разработка алгоритма сортировки слиянием}

На рисунке \ref{img:merge} приведена схема алгоритма сортировки слиянием.

\pdfimg{95mm}{merge}{Схема алгоритма сортировки слиянием}

\pagebreak

На рисунке \ref{img:merge2} приведена схема алгоритма подпрограммы слияния массивов, используемого в сортировке слиянием.

\pdfimg{225mm}{merge2}{Схема алгоритма подпрограммы слияния массивов}

\pagebreak

\section{Трудоемкость алгоритмов}

\subsection{Модель вычислений}

Чтобы провести вычисление трудоемкости алгоритмов сортировки, введем модель вычислений:

\begin{enumerate}
	\item операции из списка (\ref{for:opers}) имеют трудоемкость 1;
	\begin{equation}
		\label{for:opers}
		+, -, ==, !=, <, >, <=, >=, [], ++, {-}-, +=, -=, =, \&\&, ||
	\end{equation}
	\item операции из списка (\ref{for:opers2}) имеют трудоемкость 2;
	\begin{equation}
		\label{for:opers2}
		*, /, *=, /=, \%
	\end{equation}
	\item трудоемкость оператора выбора \code{if условие then A else B} рассчитывается, как (\ref{for:if});
	\begin{equation}
		\label{for:if}
		f_{if} = f_{\text{условия}} +
		\begin{cases}
			f_A, & \text{если условие выполняется,}\\
			f_B, & \text{иначе.}
		\end{cases}
	\end{equation}
	\item трудоемкость цикла рассчитывается, как (\ref{for:for});
	\begin{equation}
		\label{for:for}
		f_{for} = f_{\text{инициализации}} + f_{\text{сравнения}} + N(f_{\text{тела}} + f_{\text{инкремента}} + f_{\text{сравнения}})
	\end{equation}
	\item трудоемкость вызова функции равна 0.
\end{enumerate}

\subsection{Трудоёмкость алгоритма блочной сортировки}

Обозначим за $N$ длину массива.

Для алгоритма блочной сортировки трудоемкость будет слагаться из:

\begin{itemize}
	\item[---] инициализаций минимума, максимума и массива корзин, суммарная трудоёмкость которых в худшем случае: $f = 2 + 4 + 1 + 1 + N \cdot (1 + 1 + 2 + 2) = 8 + 6N$, в лучшем случае: $f = 2 + 4 + 1 + 1 + N \cdot (1 + 1 + 1 + 1) = 8 + 4N$;
	\item[---] инициализации корзин, трудоёмкость которой: $f = 1 + 1 + N \cdot (1 + 1 + 9 + 4) = 2 + 15N$;
	\item[---] цикла по $i \in [0..N-1]$, трудоёмкость которого в случае выполнения условия: $f = 1 + 1 + N \cdot (1 + 1 + 2 + 3 + f_{insertionsort})$, в случае невыполнения условия: $f = 1 + 1 + N \cdot (1 + 1 + 2 + 4 + f_{blocksort})$;
	\item[---] инициализации переменной pos, трудоёмкость которой: $f = 1$;
	\item[---] заполнения результируюшего массива из корзин, трудоёмкость которого в случае выполнения условия: $f = 1 + 1 + N \cdot (1 + 1 + 2 + (1 + 1 + N \cdot (1 + 1 + 5))) = 7N^2 + 6N + 2$, в случае невыполнения условия: $f = 1 + 1 + N \cdot (1 + 1 + 2) = 4N + 2$.
\end{itemize}

Трудоёмкость алгоритма сортировки вставками $ f_{insertionsort}$, используемого в блочной сортировке складывается из:

\begin{itemize}
	\item[---] цикла по $i \in [0..N-1]$, трудоёмкость которого в лучшем случае (на уже отсортированном масиве): $f = 1 + 1 + N \cdot (1 + 1 + 2 + 2 + 3) = 9N + 2$, в худшем случае (на отсортированном в обратном порядке массиве): $f = 1 + 1 + N \cdot (1 + 1 + 2 + 2 + (1 + 1 + 16N) + 3) = 16N^2 + 11N + 2$.
\end{itemize}

\textbf{Лучший случай} для реализуемого алгоритма блочной сортировки наступает, когда на вход подаётся массив размером меньше threshold (константа, отвечающая за выбор дальнейшего разбиения или применения алгоритма сортировки вставками) и данный массив уже отсортирован. 
В таком случае трудоёмкость алгоритма блочной сортировки составит:

$f = 8 + 4N + 2 + 15N + 1 + 1 + 1 \cdot (1 + 1 + 2 + 3 + 9N + 2) + 1 + 7 + 6 + 2 = 28N + 37$

Оценка трудоёмкости по самому быстрорастущему слагаемому из зависимости от входных данных: $O(n)$.

\textbf{Худший случай} для реализуемого алгоритма блочной сортировки наступает, когда на вход подаётся массив размером больше threshold (константа, отвечающая за выбор дальнейшего разбиения или применения алгоритма сортировки вставками) и данный массив отсортирован в обратном порядке, а также элементы равномерно распределяются по всем корзинам. 
В таком случае трудоёмкость алгоритма блочной сортировки составит:

$f = R \cdot (8 + 6N + 2 + 15N + 1 + 1 + N \cdot (1 + 1 + 2 + 3 + 8 + 6N + 2 + 15N + 1 + 1 + N \cdot (1 + 1 + 2 + 3 + 16N^2 + 11N + 2)) + 1 + 7N^2 + 6N + 2) = 16N^4R + 11N^3R + 37N^2R + 46NR + 15R$

Оценка трудоёмкости по самому быстрорастущему слагаемому из зависимости от входных данных: $O(n^4)$.

\subsection{Трудоёмкость алгоритма поразрядной сортировки}

Обозначим за $K$ максимальное количество разрядов, среди чисел массива, за $N$ --- количество чисел в массиве. 

Для алгоритма поразрядной сортировки трудоемкость будет слагаться из:

\begin{itemize}
	\item[---] поиска максимального количества разрядов, трудоёмкость которого в лучшем случае: $f = 2 + 3 + (1 + K \cdot (1 + 1 + 1)) + 1 + 1 + (N - 2) \cdot (2 + 3K + 4 + 1) + 2 + 3K + 4 + 2 = 3KN + 7N + 2$, в худшем случае: $f = 2 + 4 + (1 + K \cdot (1 + 1 + 1)) + 1 + 1 + (N - 1) \cdot (2 + 3K + 5 + 2) = 3KN + 9N - 1$;
	\item[---] создания и заполнения двумерного массива для разрядов, трудоёмкость которых: $f = 3 + 4 + 20 \cdot (4 + 2) = 127$;
	\item[---] основного цикла сортировки по разрядам по $place \in [0..K-1]$, трудоёмкость которого в лучшем случае: $f = 1 + 1 + K \cdot (1 + 1 + (1 + 1 + N \cdot (1 + 1 + 13)) + 1 + (1 + 1 + (1 + 1 + 1 + 1 + 1 + N \cdot (1 + 1 + 5) + 19 \cdot (1 + 1 + 1)) + 40)) = 22KN + 109K + 2$, в худшем случае: $1 + 1 + K \cdot (1 + 1 + (1 + 1 + N \cdot (1 + 1 + 13)) + 1 + (1 + 1 + 20 \cdot (1 + 1 + 1 + 1 + 1 + \frac{N}{20} \cdot (1 + 1 + 5) + 1))) = 22KN + 110K + 2$.
\end{itemize}

И \textbf{худший} ($f = 25KN + 110K + 9N + 128$), и \textbf{лучший случай} ($f = 25KN + 109K + 7N + 131$) существенно друг от друга не отличаются и характеризуются линейной оценкой трудоёмкости: $O(n)$


\subsection{Трудоёмкость алгоритма сортировки слиянием}

Для алгоритма сортировки слиянием трудоемкость будет слагаться из трудоёмкости собственно основной функции сортировки, осуществляющей рекурсивные вызовы, и из трудоёмкости функции слияния отсортированных частей.

Трудоёмкость функции слияния отсортированных частей для массивов длиной $N_1$ и $N_2$ складывается из:

\begin{itemize}
	\item[---] инициализации результирующего массива: $f = 1$;
	\item[---] цикла слияния массивов: $f = 3 + N_1 \cdot (3 + 3 + 4))$;
	\item[---] проверки двух условий для дозаполнения массива: $f = 1 + 1 + N_2 - N_1 = N_2 - N_1 + 2$.
\end{itemize}

Итого, трудоёмкость операции слияния массивов составляет: $f = 9N_1 + N_2 + 5$. Если массивы имеют одинаковую длину, трудоёмкость составит: $f = 10N + 5$, где $N$ --- длина результирующего массива.

Алгоритм, получая на входе массив из $N$ элементов, делит его пополам, поэтому будет рассмотрен случай, когда $N = 2^k, k = \log_2 N$.

В этом случае при рекурсивных вызовах строится полное дерево рекурсивных вызовов глубиной $k$, содержащее $N$ листьев. Если количество вершин дерева обозначить через $V$, то его можно выразить следующим образом:

\begin{equation}
	V = N + \frac{N}{2} + \frac{N}{4} + \ldots + 1 = n \cdot (1 + \frac{1}{2} + \frac{1}{4} + \ldots + 1) = 2N - 1 = 2^{k+1} - 1
\end{equation}

Из $2^{k+1} - 1$ все внутренние вершины порождают рекурсию, количество таких вершин --- $V_r = N - 1$, остальные $N$ вершин --- это вершины, в которых рассматривается только один элемент массива, что не вызывает дальнейших рекурсивных вызовов.

Таким образом, для $N$ вершин суммарная трудоёмкость составит: $f = 1 \cdot N = N$.

Cуммарная трудоёмкость в любом случае составит: $f = (4 + 10N + 5) + (4 + 10\cdot\frac{N}{2} + 5) + (4 + 10 \cdot \frac{N}{4} + 5) + \ldots = 9 + N + (k - 1) \cdot (10N + 5) = 9 + N + (\log_2 N - 1) \cdot (10N + 5) = 10N\log_2 N + 5\log_2 N - 9N +4$. 


Оценка трудоёмкости по самому быстрорастущему слагаемому из зависимости от входных данных: $O(n\log n)$.


\section*{Вывод}

В данном разделе представлены схемы алгоритмов сортировки массивов целых чисел: алгоритма блочной сортировки, алгоритма поразрядной сортировки, алгоритма сортировки слиянием, также оценена их трудоёмкость.

По итогам расчётов алгоритм блочной сортировки в худшем случае имеет наибольшую трудоёмкость $O(n^4)$. Данный алгоритм сильно зависит от выбора функции распределения элементов по корзинам, а также от природы входных данных. Однако в лучшем случае имеет линейную оценку трудоёмкости $O(n)$.


Наименее трудоёмким является алгоритм поразрядной сортировки: он имеет линейную оценку трудоёмкости $O(n)$ на всех  наборах, с которыми может работать. Однако данный алгоритм сортировки сильно ограничен в типах элементов наборов, что делает его неприменимым во многих задачах.


Алгоритм сортировки слиянием во всех случаях имеет оценку трудоёмкости $O(n\log n)$, что делает его применимым в задачах, в которых неизвестно ничего о внутреннем устройстве входных данных.

