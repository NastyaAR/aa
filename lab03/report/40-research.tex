\chapter{Исследовательская часть}

\section{Технические характеристики}

Технические характеристики устройства, на котором выполнялось тестирование:

\begin{itemize}
	\item[---] операционная система: Ubuntu \cite{ubuntu} 22.04.3 LTS;
	\item[---] оперативная память: 15 ГБ;
	\item[---] процессор: 12 ядер, AMD Ryzen 5 4600ГЦ with Radeon Graphics \cite{amd}.
\end{itemize}


\section{Время выполнения алгоритмов}
Все замеры были проведены в одинаковых условиях.

Замеры проводились с помощью разработанной функции GetCPU, которая использует модуль syscall \cite{syscall}. syscall.Rusage является структурой в пакете syscall, предназначенной для хранения информации о ресурсах, используемых процессом или потоком. Эта структура содержит различные поля, такие как Utime (время использования ЦПУ в пользовательском режиме), Stime (время использования ЦПУ в режиме ядра) и так далее.

Для получения времени использования ЦПУ, извлекаем атрибуты структуры Utime и Stime.

Выражение usage.Utime.Nano() + usage.Stime.Nano() возвращает сумму времени использования ЦПУ в наносекундах для процесса или потока. Это значение может быть использовано для измерения общего времени использования ЦПУ в пределах процесса или потока.

По устройству входных данных можно выделить четыре случая:
\begin{itemize}
	\item[---] неупорядоченный массив, заполненный случайными числами;
	\item[---] уже отсортированный массив, заполненный случайными числами;
	\item[---] отсортированный в обратном порядке массив, заполненный случайными числами;
	\item[---] массив, заполненный одинаковыми числами.
\end{itemize}

Обозначим: 
\begin{itemize}
	\item[---] 1 --- алгоритм блочной сортировки;
	\item[---] 2 --- алгоритм поразрядной сортировки;
	\item[---] 3 --- алгоритм сортировки слиянием.
\end{itemize}

Для случая 1 (неупорядоченный массив, заполненный случайными числами) результаты замеров приведены в таблице \ref{tbl:time1}.

\begin{table}[h]
	\begin{center}
		\caption{Замер времени для массивов размером от 60 до 960: неупорядоченный массив, заполненный случайными числами}
		\label{tbl:time1}
		\begin{tabular}{|c|c|c|c|c|c|c|}
			\hline
			                      & \multicolumn{3}{c|}{\bfseries Время, с}                                    \\ \cline{2-4}
			\bfseries Размер массива & \bfseries 1 & \bfseries 2 & \bfseries 3
			\csvreader{inc/csv/random.csv}{}
			{\\\hline \csvcoli&\csvcolii&\csvcoliii&\csvcoliv}
			\\\hline
		\end{tabular}
	\end{center}
\end{table}

Для случая 2 (уже отсортированный массив, заполненный случайными числами) результаты замеров приведены в таблице \ref{tbl:time2}.

\begin{table}[h]
	\begin{center}
		\caption{Замер времени для массивов размером от 60 до 960: уже отсортированный массив, заполненный случайными числами}
		\label{tbl:time2}
		\begin{tabular}{|c|c|c|c|c|c|c|}
			\hline
			& \multicolumn{3}{c|}{\bfseries Время, с}                                    \\ \cline{2-4}
			\bfseries Размер массива & \bfseries 1 & \bfseries 2 & \bfseries 3
			\csvreader{inc/csv/randomSort.csv}{}
			{\\\hline \csvcoli&\csvcolii&\csvcoliii&\csvcoliv}
			\\\hline
		\end{tabular}
	\end{center}
\end{table}

\newpage

Для случая 3 (отсортированный в обратном порядке массив, заполненный случайными числами) результаты замеров приведены в таблице \ref{tbl:time3}.

\begin{table}[h]
	\begin{center}
		\caption{Замер времени для массивов размером от 60 до 960: отсортированный в обратном порядке массив, заполненный случайными числами}
		\label{tbl:time3}
		\begin{tabular}{|c|c|c|c|c|c|c|}
			\hline
			& \multicolumn{3}{c|}{\bfseries Время, с}                                    \\ \cline{2-4}
			\bfseries Размер массива & \bfseries 1 & \bfseries 2 & \bfseries 3
			\csvreader{inc/csv/randomRevSort.csv}{}
			{\\\hline \csvcoli&\csvcolii&\csvcoliii&\csvcoliv}
			\\\hline
		\end{tabular}
	\end{center}
\end{table}

\newpage

Для случая 4 (массив, заполненный одинаковыми числами) результаты замеров приведены в таблице \ref{tbl:time4}.

\begin{table}[h]
	\begin{center}
		\caption{Замер времени для массивов размером от 60 до 960: массив, заполненный одинаковыми числами}
		\label{tbl:time4}
		\begin{tabular}{|c|c|c|c|c|c|c|}
			\hline
			& \multicolumn{3}{c|}{\bfseries Время, с}                                    \\ \cline{2-4}
			\bfseries Размер массива & \bfseries 1 & \bfseries 2 & \bfseries 3
			\csvreader{inc/csv/same.csv}{}
			{\\\hline \csvcoli&\csvcolii&\csvcoliii&\csvcoliv}
			\\\hline
		\end{tabular}
	\end{center}
\end{table}

\newpage

На следующем графике представлена зависимость времени работы алгоритмов сортировки от размера массива в случае 1 (неупорядоченный массив, заполненный случайными числами).

\img{90mm}{graph1}{Время работы реализаций алгоритмов сортировки на неупорядоченном массиве}

\pagebreak

На следующем графике представлена зависимость времени работы алгоритмов сортировки от размера массива в случае 2 (уже отсортированный массив, заполненный случайными числами).

\img{90mm}{graph2}{Время работы реализаций алгоритмов сортировки на отсортированном массиве}

\pagebreak

На следующем графике представлена зависимость времени работы алгоритмов сортировки от размера массива в случае 3 (отсортированный в обратном порядке массив, заполненный случайными числами).

\img{90mm}{graph3}{Время работы реализаций алгоритмов сортировки на отсортированном в обратном порядке массиве}

На следующем графике представлена зависимость времени работы алгоритмов сортировки от размера массива в случае 4 (массив, заполненный одинаковыми числамии).

\img{90mm}{graph4}{Время работы реализаций алгоритмов сортировки на массиве, заполненном одинаковыми числами}

\newpage

\section{Использование памяти}

Выделение памяти при работе реализаций алгоритмов указано в листинге \ref{lst:memory}. Получено при помощи команды: \code{go test -bench . -benchmem}.

\newpage

\begin{lstinputlisting}[
	caption={Использование памяти},
	label={lst:memory},
	style={sh},
	linerange{1-14},
	]{../report/inc/lst/lst2.txt}
\end{lstinputlisting}

\newpage

На рисунке \ref{img:graph8} представлено сравнение потребления памяти реализациями алгоритмов сортировки.

\img{90mm}{graph8}{Память, потребляемая реализациями алгоритмов сортировки}

Реализация алгоритма блочной сортировки потребляет больше всего памяти, так как в ней выделяется множество блоков. Реализация алгоритма сортировки слиянием потребляет наименьшее количество памяти.

\pagebreak

\section*{Вывод}

Реализация алгоритма блочной сортировки потребляет больше всего памяти и является наименее эффективной по времени. 
Это соотносится с оценкой трудоёмкости алгоритмов.

Реализации алгоритмов сортировки слиянием и поразрядной сортировки имеют примерно одинаковое время исполнения. 
Реализация алгоритма сортировки слиянием потребляет меньше всего памяти.


